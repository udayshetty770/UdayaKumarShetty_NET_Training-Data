Next Greater Element III

Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1.

Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.

 

Example 1:

Input: n = 12
Output: 21
Example 2:

Input: n = 21
Output: -1
 

Constraints:

1 <= n <= 231 - 1

Solutions : 

public class Solution{    public int NextGreaterElement(int n)
        {
            char[] inp = n.ToString().ToCharArray();

            // Step 1: Find the largest index k such that inp[k] < inp[k + 1]
            int k = -1;
            for (int i = inp.Length - 2; i >= 0; i--)
            {
                if (inp[i] < inp[i + 1])
                {
                    k = i;
                    break;
                }
            }

            if (k == -1)
            {
                return -1;
            }

            // Step 2: Find the largest index l such that inp[l] > inp[k]
            int largerIdx = inp.Length - 1;
            for (int i = inp.Length - 1; i >= 0; i--)
            {
                if (inp[i] > inp[k])
                {
                    largerIdx = i;
                    break;
                }
            }

            Swap(inp, k, largerIdx);
            Reverse(inp, k + 1, inp.Length - 1);

            // Step 3: Convert char[] back to int with overflow check
            long ret = 0;
            foreach (char c in inp)
            {
                int digit = c - '0';
                ret = ret * 10 + digit;
                if (ret > int.MaxValue)
                {
                    return -1;
                }
            }

            return (int)ret;
        }

        private void Swap(char[] inp, int i, int j)
        {
            char temp = inp[i];
            inp[i] = inp[j];
            inp[j] = temp;
        }

        private void Reverse(char[] inp, int start, int end)
        {
            while (start < end)
            {
                char temp = inp[start];
                inp[start] = inp[end];
                inp[end] = temp;
                start++;
                end--;
            }
        }
    }